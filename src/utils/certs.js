import forge from "node-forge"
import {settings} from "./store";
import * as os from "node:os";
import crypto from 'crypto';
import fs from "node:fs";
import path from "node:path";
import ignore from "ignore";
import {NotificationCenter} from "./NotificationCenter";
import {safeReadFileSync} from "./safeReadFileSync";

export const Certs = {
    EXPIRY_THRESHOLD_DAYS: 90,
    generateDefaultFdoIgnore() {
        return [
            "# .fdoignore autogenerated by FDO",
            "*.log",
            "*.tmp",
            "*.cache",
            "*.bak",
            ".store.json",
            ".*-audit.json",
        ].join(this.LINE_END()) + this.LINE_END();
    },
    IS_WIN() {
        return typeof process !== 'undefined' && process.platform === 'win32'
    },
    LINE_END() {
        return this.IS_WIN() ? '\r\n' : '\n'
    },

    daysUntilExpiry(certPem) {
        const cert = forge.pki.certificateFromPem(certPem);
        const notAfter = cert.validity.notAfter;
        return (notAfter - new Date()) / (1000 * 60 * 60 * 24);
    },

    generateRootCA(label = 'root', update = false) {
        NotificationCenter.addNotification({title: ``, message: `ðŸ” Generating new FDO Root Certificate...`});

        const keys = forge.pki.rsa.generateKeyPair(4096);
        const cert = forge.pki.createCertificate();

        cert.publicKey = keys.publicKey;
        cert.serialNumber = Date.now().toString();
        cert.validity.notBefore = new Date();
        cert.validity.notAfter = new Date();
        cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 1);

        const attrs = [
            {name: 'commonName', value: 'FDO Root CA'},
            {name: 'organizationName', value: 'FDO'},
        ];
        cert.setSubject(attrs);
        cert.setIssuer(attrs);
        cert.setExtensions([
            {name: 'basicConstraints', cA: true},
            {name: 'keyUsage', keyCertSign: true, digitalSignature: true},
        ]);

        cert.sign(keys.privateKey, forge.md.sha256.create());

        const certPem = forge.pki.certificateToPem(cert);
        const keyPem = forge.pki.privateKeyToPem(keys.privateKey);

        // Calculate SHA256 fingerprint of cert PEM
        const sha256 = crypto.createHash('sha256').update(certPem).digest('base64');
        const id = `SHA256://${sha256}`;

        // Get system identity
        const user = os.userInfo().username;
        const host = os.hostname();
        const identity = `${user}@${host}`;

        const now = new Date();

        // Store as array of root certs
        const roots = settings.get('certificates.root') || [];

        if (!update) {
            roots.push({
                key: keyPem,
                cert: certPem,
                id,
                identity,
                label,
                createdAt: now.toISOString(),
                expiresAt: cert.validity.notAfter.toISOString(),
                lastUsedAt: now.toISOString(),
                imported: false
            });
        } else {
            const root = roots.find((root) => root.label === label);
            if (root) {
                root.key = keyPem;
                root.cert = certPem;
                root.id = id;
                root.identity = identity;
                root.createdAt = now.toISOString();
                root.expiresAt = cert.validity.notAfter.toISOString();
                root.lastUsedAt = now.toISOString();
                root.imported = false;
            }
        }

        settings.set('certificates.root', roots);

        NotificationCenter.addNotification({title: ``, message: `âœ… Root certificate created and added as identity: ${identity}`});
    },

    setLabel(id, newName) {
        const roots = settings.get('certificates.root') || [];
        const root = roots.find((root) => root.id === id);
        if (root) {
            root.label = newName;
        }
        settings.set('certificates.root', roots);
    },

    export(id) {
        const roots = settings.get('certificates.root') || [];
        const root = roots.find((root) => root.id === id);
        if (root) {
            return {
                cert: root.cert,
            };
        }
        return null;
    },

    async import(file) {
        try {
            const filePath = path.resolve(file);
            const pem = fs.readFileSync(filePath, "utf-8");

            // Split PEM into blocks (certs and private key)
            const pemBlocks = pem
                .split(/(?=-----BEGIN (?:CERTIFICATE|.*PRIVATE KEY)-----)/g)
                .map(block => block.trim())
                .filter(block => block.length > 0);

            const certs = [];
            let privateKeyPem = null;

            for (const block of pemBlocks) {
                if (block.includes("CERTIFICATE")) {
                    try {
                        certs.push({
                            pem: block,
                            cert: forge.pki.certificateFromPem(block)
                        });
                    } catch {
                        return { success: false, error: "Invalid certificate block" };
                    }
                } else if (block.includes("PRIVATE KEY")) {
                    privateKeyPem = block;
                }
            }

            if (certs.length === 0) {
                return { success: false, error: "No valid certificates found" };
            }

            const now = new Date();
            const leaf = certs[0];
            if (leaf.cert.validity.notAfter <= now) {
                return { success: false, error: "Certificate is expired" };
            }

            // Validate private key matches public key in leaf cert (if provided)
            let privateKey = null;
            let keyMatches = false;

            if (privateKeyPem) {
                try {
                    privateKey = forge.pki.privateKeyFromPem(privateKeyPem);
                    const publicKeyFromCert = leaf.cert.publicKey;

                    // Compare modulus and exponent (RSA)
                    keyMatches = (
                        publicKeyFromCert.n?.toString() === privateKey.n?.toString() &&
                        publicKeyFromCert.e?.toString() === privateKey.e?.toString()
                    );

                    if (!keyMatches) {
                        return { success: false, error: "Private key does not match certificate" };
                    }
                } catch (err) {
                    return { success: false, error: "Invalid private key format: " + err.message };
                }
            }

            // Save to store
            const sha256 = crypto.createHash("sha256").update(leaf.pem).digest("base64");
            const id = `SHA256://${sha256}`;
            const roots = settings.get("certificates.root") || [];

            if (roots.find(root => root.id === id)) {
                return { success: false, error: "Certificate already exists" };
            }

            const entry = {
                cert: leaf.pem,
                id,
                label: `Imported-${(Math.random() + 1).toString(36).substring(2)}`,
                createdAt: now.toISOString(),
                expiresAt: leaf.cert.validity.notAfter.toISOString(),
                lastUsedAt: now.toISOString(),
                imported: true
            };

            if (certs.length > 1) {
                entry.chain = certs.map(c => c.pem);
            }

            if (keyMatches && privateKeyPem) {
                entry.key = privateKeyPem;
            }

            roots.push(entry);
            settings.set("certificates.root", roots);

            return { success: true };
        } catch (err) {
            return { success: false, error: "Failed to import certificate: " + err.message };
        }
    },

    loadIgnorePatterns(pluginDir) {
        const ignoreFile = path.join(pluginDir, ".fdoignore");
        if (!fs.existsSync(ignoreFile)) return null;

        const content = fs.readFileSync(ignoreFile, "utf-8");
        const ig = ignore();
        ig.add(content.split(/\r?\n/).filter(Boolean));
        return ig;
    },

    hashPluginDir(pluginDir) {
        const hash = crypto.createHash("sha256");
        const ig = this.loadIgnorePatterns(pluginDir);

        const walk = (dir) => {
            fs.readdirSync(dir).forEach((file) => {
                const fullPath = path.join(dir, file);
                const relPath = path.relative(pluginDir, fullPath);

                // Always ignore meta + sig files
                if (["fdo.meta.json", "fdo.signature", ".fdoignore"].includes(file)) return;
                // Skip ignored files
                if (ig && ig.ignores(relPath)) return;

                const stat = fs.statSync(fullPath);
                if (stat.isDirectory()) {
                    walk(fullPath);
                } else {
                    const content = fs.readFileSync(fullPath);
                    hash.update(content);
                }
            });
        };

        walk(pluginDir);
        return hash.digest();
    },

    ensureFdoIgnore(pluginDir) {
        const ignorePath = path.join(pluginDir, ".fdoignore");

        if (fs.existsSync(ignorePath)) {
            const content = fs.readFileSync(ignorePath, "utf-8");
            const isAutoGenerated = content.startsWith("# .fdoignore autogenerated by FDO");

            if (!isAutoGenerated) {
                NotificationCenter.addNotification({title: `Checking .fdoignore`, message: `âœ… Found custom .fdoignore. Not overwriting.`});
                return;
            }
        }

        const content = this.generateDefaultFdoIgnore();
        fs.writeFileSync(ignorePath, content, "utf-8");
        NotificationCenter.addNotification({title: `Checking .fdoignore`, message: `ðŸ›¡ï¸ Created auto-generated .fdoignore for plugin at ${pluginDir}`});
    },


    signPlugin(pluginDir, signerLabel) {
        const roots = settings.get("certificates.root") || [];
        const certEntry = roots.find(cert => cert.label === signerLabel);

        if (!certEntry || !certEntry.key) {
            return {success: false, error: "Signer not found or missing private key"}
        }

        this.ensureFdoIgnore(pluginDir);

        const certObj = forge.pki.certificateFromPem(certEntry.cert);
        const now = new Date();
        if (certObj.validity.notBefore > now) {
            return {success: false, error: `Certificate not valid before ${certObj.validity.notBefore.toISOString()}`};
        }
        if (certObj.validity.notAfter <= now) {
            return {success: false, error: `Certificate expired on ${certObj.validity.notAfter.toISOString()}`};
        }

        const privateKey = forge.pki.privateKeyFromPem(certEntry.key);
        const hash = this.hashPluginDir(pluginDir);

        const md = forge.md.sha256.create();
        md.update(hash.toString("binary"));

        const signature = privateKey.sign(md);

        const normalizedCert = certEntry.cert.trim().replace(/\r\n/g, '\n');
        const fingerprint = crypto.createHash("sha256").update(normalizedCert).digest("base64");

        // ðŸ” Check if the certificate is a CA
        let isRoot = false;
        for (const ext of certObj.extensions) {
            if (ext.name === 'basicConstraints' && ext.cA === true) {
                isRoot = true;
                break;
            }
        }

        const metaInformation = {
            fingerprint: {
                algo: "SHA256",
                value: fingerprint
            },
            label: certEntry.label,
            identity: certEntry.identity,
            signedAt: new Date().toISOString(),
            signatureEncoding: "base64",
            hashAlgorithm: "sha256",
            signatureAlgorithm: "RSASSA-PKCS1-v1_5",
            signedBy: isRoot ? "root" : "developer",
        }

        if (!isRoot) {
            metaInformation.developerCert = certEntry.chain?.length > 1
                ? { chain: [certEntry.cert, ...certEntry.chain.slice(1)] }
                : { cert: certEntry.cert };
        }

        fs.writeFileSync(path.join(pluginDir, "fdo.signature"), Buffer.from(signature, "binary"));
        fs.writeFileSync(
            path.join(pluginDir, "fdo.meta.json"),
            JSON.stringify(metaInformation, null, 2) + this.LINE_END()
        );

        return {success: true}
    },

    verifyPluginSignature(pluginDir, signature, certPem, meta) {
        const {
            signatureEncoding = "base64",
            hashAlgorithm = "sha256",
            signatureAlgorithm = "RSASSA-PKCS1-v1_5"
        } = meta;

        if (signatureAlgorithm !== "RSASSA-PKCS1-v1_5") {
            return {success: false, error: `Unsupported signature algorithm: ${signatureAlgorithm}`};
        }

        try {
            // 1. Hash the plugin content
            const pluginHash = this.hashPluginDir(pluginDir);
            const md = forge.md[hashAlgorithm];
            if (!md) return {success: false, error: `Unsupported hash algorithm: ${hashAlgorithm}`};
            const digest = md.create();
            digest.update(pluginHash.toString("binary"));

            // 2. Parse cert and validate validity
            const certObj = forge.pki.certificateFromPem(certPem);
            const now = new Date();
            if (certObj.validity.notBefore > now) {
                return {
                    success: false,
                    error: `Certificate not valid before ${certObj.validity.notBefore.toISOString()}`
                };
            }
            if (certObj.validity.notAfter <= now) {
                return {success: false, error: `Certificate expired on ${certObj.validity.notAfter.toISOString()}`};
            }

            const publicKey = certObj.publicKey;

            // 3. Decode signature
            let binarySignature;
            if (Buffer.isBuffer(signature)) {
                binarySignature = signature.toString("binary");
            } else {
                const buf = Buffer.from(signature, signatureEncoding);
                binarySignature = buf.toString("binary");
            }

            // 4. Verify signature
            const isValid = publicKey.verify(digest.digest().bytes(), binarySignature);
            return isValid ? {success: true, cert: certObj} : {success: false, error: "Signature is invalid."};
        } catch (err) {
            return {success: false, error: `Verification of signature failed: ${err.message}`};
        }
    },

    async verifyPlugin(pluginDir) {
        try {
            const metaPath = path.join(pluginDir, "fdo.meta.json");
            const sigPath = path.join(pluginDir, "fdo.signature");

            if (!fs.existsSync(metaPath) || !fs.existsSync(sigPath)) {
                return {success: false, error: "Missing signature or metadata file."};
            }

            const meta = JSON.parse(await safeReadFileSync(metaPath, "utf-8"));
            const signatureBuffer = await safeReadFileSync(sigPath);

            if (
                typeof meta.fingerprint?.value !== "string" ||
                meta.fingerprint.algo?.toLowerCase() !== "sha256"
            ) {
                return {
                    success: false,
                    error: "Invalid or unsupported fingerprint format in metadata.",
                };
            }

            const allCerts = [
                ...(settings.get("certificates.root") || []),
                ...(settings.get("certificates.org") || []),
                ...(settings.get("certificates.registry") || []),
            ];

            let matchedCert;
            let certificateToVerifyAgainst;

            if (meta.signedBy === "developer") {
                if (!meta.developerCert) {
                    return {success: false, error: "Missing developer certificate in meta."};
                }

                const rawChain = meta.developerCert.chain || [meta.developerCert.cert];
                if (!Array.isArray(rawChain) || rawChain.length === 0) {
                    return {success: false, error: "Developer certificate chain is missing or invalid."};
                }

                let certChain;
                try {
                    certChain = rawChain.map(pem => forge.pki.certificateFromPem(pem));
                } catch (e) {
                    return {success: false, error: `Failed to parse developer certificate chain: ${e.message}`};
                }

                const caStore = forge.pki.createCaStore(
                    allCerts.map(certEntry => forge.pki.certificateFromPem(certEntry.cert))
                );

                try {
                    forge.pki.verifyCertificateChain(caStore, certChain);
                } catch (e) {
                    return {
                        success: false,
                        error: `Developer certificate chain verification failed: ${e.message}`
                    };
                }

                const leafCert = certChain[0];
                const trustedRoots = allCerts.map(entry => ({
                    pem: entry.cert,
                    cert: forge.pki.certificateFromPem(entry.cert)
                }));

                const issuerString = leafCert.issuer.attributes.map(attr => `${attr.name}=${attr.value}`).join(", ");

                let matchedRoot = trustedRoots.find(root => {
                    const subjectString = root.cert.subject.attributes.map(attr => `${attr.name}=${attr.value}`).join(", ");
                    return subjectString === issuerString;
                });

                if (!matchedRoot) {
                    const lastChainCert = certChain[certChain.length - 1];
                    matchedRoot = trustedRoots.find(root => {
                        return root.cert.subject.hash === lastChainCert.issuer.hash;
                    })
                }

                matchedCert = allCerts.find(entry => {
                    const parsed = forge.pki.certificateFromPem(entry.cert);
                    return parsed.subject.hash === matchedRoot.cert.subject.hash;
                });

                certificateToVerifyAgainst = rawChain[0]
            } else {
                matchedCert = allCerts.find((cert) => {
                    const normalizedCert = cert.cert.trim().replace(/\r\n/g, '\n');
                    const fingerprint = crypto
                        .createHash("sha256")
                        .update(normalizedCert)
                        .digest("base64");
                    return fingerprint === meta.fingerprint.value;
                });

                if (!matchedCert || !matchedCert?.cert) {
                    return {success: false, error: "Signer certificate not found."};
                }

                certificateToVerifyAgainst = matchedCert.cert
            }

            const verifySig = this.verifyPluginSignature(pluginDir, signatureBuffer, certificateToVerifyAgainst, meta);
            if (!verifySig.success) {
                return verifySig;
            }

            matchedCert.lastUsedAt = new Date().toISOString();

            const updatedCerts = allCerts.map(cert =>
                cert.id === matchedCert.id ? matchedCert : cert
            );
            settings.set("certificates.root", updatedCerts);

            return {
                success: true,
                commonName: verifySig.cert.subject.attributes.find(attr => attr.name === 'commonName'),
                signer: matchedCert,
            };
        } catch (err) {
            return {
                success: false,
                error: `Verification failed: ${err.message}`,
            };
        }
    },
}